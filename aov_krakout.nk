set cut_paste_input [stack 0]
version 10.5 v5
push $cut_paste_input
NoOp {
name aov_krakout4
tile_color 0xff
selected true
xpos -815
ypos 122
addUserKnob {20 User}
addUserKnob {4 direction l "krakout to" M {left right "" "" ""}}
addUserKnob {3 x_space l "x grid units" t "this is the amount of horizontal working space generated between each aov"}
x_space 2
addUserKnob {3 y_space l "y grid units small" t "vertically space out dots and shuffles Y grid units"}
y_space 3
addUserKnob {3 large_y_space l "y grid units large" t "this is the amount of vertical working space generated"}
large_y_space 10
addUserKnob {1 aov_pattern l "match pattern" t "Uses a wildcard system for searching aov layers. AOVs will vary depending on show and facility:\n\n*group*,*emission* <- use this to break out light groups\n*coat*,*dir*,*spec*,*sss*,*mission* <- use this system to break out illumination"}
aov_pattern *group*,*emission*
addUserKnob {22 krakout l krakout! t "Breakout that tree like a big nuke pimple" T "import fnmatch\n\ndef retrieveLayers (n, pattern):\n    channels = n.channels()\n    layers = list( set(\[c.split('.')\[0] for c in channels]) )\n    layers.sort()\n\n    matchLayers = \[]\n    notMatchLayers = \[]\n    for p in pattern.replace(' ','').split(','):\n        matchLayers += (fnmatch.filter(layers, p))\n        if p\[0] == '!':\n            notMatchLayers += (fnmatch.filter(layers, p\[1:]))\n    \n    matchLayers = list(set(matchLayers)-set(notMatchLayers))\n    matchLayers.sort()\n    return matchLayers\n\ndef breakout(n):\n    #---- find the layers we want to break out\n    pattern = n\['aov_pattern'].value()\n    matchLayers = retrieveLayers (n,pattern)\n    \n    #---- exit early if there is no layer match\n    if len(matchLayers) == 0:\n        nuke.message ('Nothing to breakout')\n        return\n    \n    #---- constant stuff\n    pref = nuke.toNode('preferences') \n    gw = pref\['GridWidth'].value()\n    gh = pref\['GridHeight'].value()\n    th = pref\['TileHeight'].value()\n    d  = int(pref\['dot_node_scale'].value())\n    nx = n.xpos()\n    ny = n.ypos()\n    \n    \n    #---- grab variables from knobs\n    direction = 1\n    if n\['direction'].value() == 'left':\n        direction = -1\n    xOffset = int(abs(n\['x_space'].value()))*direction\n    yOffset1 = int(abs(n\['y_space'].value()))\n    yOffset2 = int(abs(n\['large_y_space'].value()))\n    \n    \n    # ---- build a tree\n    i=1\n    lastMerge=None\n    firstMerge=None\n    firstDot = nuke.nodes.Dot( xpos = nx, ypos = ny+gh*yOffset1*2 )\n    firstDot.setXpos( int( firstDot.xpos() - d*6 + n.screenWidth()/2 ) )\n    firstDot.setYpos( int( firstDot.ypos() - d*6 + n.screenHeight()/2 ) )\n    firstDot.setInput(0,n)\n    lastDot = firstDot\n    \n    for m in matchLayers:\n        x = nx+gw*i*xOffset\n        y = ny+gh*yOffset1*2\n        topDot = nuke.nodes.Dot( xpos = x, ypos = y )\n        topDot.setXpos( int( topDot.xpos() - d*6 + n.screenWidth()/2 ) )\n        topDot.setYpos( int( topDot.ypos() - d*6 + n.screenHeight()/2 ) )\n        topDot.setInput(0,lastDot)\n        lastDot = topDot\n    \n        shuffleOut = nuke.nodes.Shuffle( xpos = x, ypos = topDot.ypos() + gh*yOffset1  )\n        shuffleOut\['label'].setValue('\[value in] -> \[value out]')\n        shuffleOut\['in'].setValue(matchLayers\[i-1])\n        shuffleOut\['out'].setValue('rgb')\n        shuffleOut.setInput(0,topDot)\n    \n        unpremult = nuke.nodes.Unpremult( xpos = x, ypos = shuffleOut.ypos() + gh*yOffset1  )\n        unpremult.setInput(0,shuffleOut)\n        \n        shuffleIn = nuke.nodes.Shuffle( xpos = x, ypos = unpremult.ypos() + gh*yOffset2  )\n        shuffleIn\['label'].setValue('\[value in] -> \[value out]')\n        shuffleIn\['out'].setValue(matchLayers\[i-1])\n        shuffleIn\['in'].setValue('rgb')\n        shuffleIn.setInput(0,unpremult)\n    \n        premult = nuke.nodes.Premult( xpos = x, ypos = shuffleIn.ypos() + gh*yOffset1  )\n        premult\['channels'].setValue(matchLayers\[i-1])\n        premult.setInput(0,shuffleIn)\n\n        if i == len(matchLayers):\n            bottomMerge = nuke.nodes.Remove( xpos = x, ypos = premult.ypos()+yOffset1*gh-th/4 )\n            bottomMerge\['operation'].setValue('keep')\n            bottomMerge\['channels'].setValue('rgba')\n            bottomMerge.setInput(0,premult)\n        else:\n            bottomMerge = nuke.nodes.Merge2( xpos = x, ypos = premult.ypos()+yOffset1*gh )\n            bottomMerge\['operation'].setValue('plus')\n            bottomMerge\['Achannels'].setValue('rgb')\n            bottomMerge\['Bchannels'].setValue('rgb')\n            bottomMerge\['output'].setValue('rgb')\n            bottomMerge\['also_merge'].setValue(matchLayers\[i-1])\n            bottomMerge.setInput(1,premult)\n        if lastMerge:\n            lastMerge.setInput(0,bottomMerge)\n        if not firstMerge:\n            firstMerge = bottomMerge\n        lastMerge = bottomMerge\n        i += 1\n    \n    copy = nuke.nodes.Merge2( xpos = n.xpos(), ypos = lastMerge.ypos()+th/4 )\n    copy.setInput(0,firstDot)\n    copy.setInput(1,firstMerge)\n    copy\['operation'].setValue('copy')\n    copy\['Achannels'].setValue('rgb')\n    copy\['Bchannels'].setValue('rgb')\n    copy\['output'].setValue('rgb')\n    copy\['also_merge'].setValue('all')\n    copy\['bbox'].setValue('B')\n    \n    premultEnd = nuke.nodes.Premult( xpos = n.xpos(), ypos = copy.ypos() + gh*yOffset1  )\n    premultEnd.setInput(0,copy)\n    \nbreakout(nuke.thisNode())" +STARTLINE}
addUserKnob {26 ""}
addUserKnob {26 version l "" +STARTLINE T "Creates a tree of lightgroups or illumination passes and recombines them\n\nv003 @darkness 2018-09-17"}
}
