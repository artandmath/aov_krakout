set cut_paste_input [stack 0]
version 13.0 v1
push $cut_paste_input
NoOp {
 name aov_krakout
 tile_color 0xff
 selected true
 xpos -370
 ypos 567
 addUserKnob {20 User}
 addUserKnob {4 direction l "krakout to" t "The direction the AOV tree will break out from this node." M {left right "" "" "" "" ""}}
 addUserKnob {3 x_space l "X grid units" t "This is the amount of horizontal working space generated between each aov"}
 x_space 6
 addUserKnob {3 y_space l "Y grid units - small" t "This is int amount of vertical space between dots and shuffles in grid height units."}
 y_space 4
 addUserKnob {3 large_y_space l "Y grid units - large" t "This is the amount of vertical working space generated in grid height units."}
 large_y_space 40
 addUserKnob {1 aov_pattern l "match patterns" t "Uses a bash style query system for searching AOV layers.\n\n<b>,</b> -> separates each AOV search query\n<b>/</b> -> divide AOV by another AOV and multiply back together\n<b>^</b> -> multiply AOV by another\n<b>!</b> -> exclude this AOV\n<b>*</b> -> wildcard to capture multiple AOVs - works with /,^,!\n<b>\$</b> -> parse an environment variable\n\nExamples:\n<i>lg*,!lg0</i>\nFetch all AOVs starting with 'lg', ignore 'lg0'.\n\n<i>light/diffuse,reflect,refractRaw*refractFilter,spec,gi</i>\nExplicitly break out some aovs. Divide 'light' by 'diffuse' multiply 'refractRaw' by 'refractFilter'.\n\n<i>\$char_aovs</i>\nParse environment variabe 'char_aovs'."}
 aov_pattern examples,lg*,!lg0,light/diffuse,reflectRaw^reflectFilter
 addUserKnob {6 x_half_space l "half x grid units for ^/ queries" t "Use half the amount of horizontal working space between each aov if dividing or multiplying one AOV by another using the '/' or '^' query terms." +STARTLINE}
 addUserKnob {6 merge_orphan_aovs l "subtract sum of aovs from rgb" t "Gather up any left over data that wasn't captured by the renderer by subtracting the queried AOVs from the rgb.\n\nBetter to fix your lighting than use this functionality :)" +STARTLINE}
 addUserKnob {22 krakout l krakout! t "Break out AOVs and recombine." T "import nuke,os,fnmatch\n\n'''GLOBALS\n'''\nn = nuke.thisNode()\n# fetch user's nodegraph prefs\npref = nuke.toNode('preferences')\ntw = pref\['TileWidth'].value() \ngw = pref\['GridWidth'].value()\ngh = pref\['GridHeight'].value()\nth = pref\['TileHeight'].value()\nd  = int(pref\['dot_node_scale'].value())\n\n#grab globals from thisNode() knobs\ndirection = 1\nif n\['direction'].value() == 'left':\n    direction = -1\nyOffset1 = int(abs(n\['y_space'].value()))\nyOffset2 = int(abs(n\['large_y_space'].value()))\nxOffset  = int(abs(n\['x_space'].value()))*direction\nxOffsetMult = 1/(n\['x_half_space'].value()+1)\n\ndef resolveEnvVars(pattern):\n    retPattern = ''\n    if len(pattern)==0:\n        return retPattern\n        \n    for p in pattern.replace(' ','').split(','):\n        if p\[0] == '\$':\n            retPattern = '\{0\},\{1\}'.format(retPattern,os.getenv(p\[1:]))\n        else:\n            retPattern = '\{0\},\{1\}'.format(retPattern,p)\n    return retPattern\[1:]\n              \ndef retrieveLayers(n, pattern):\n    #---- fetch all layers in the nuke script\n    allChannels = n.channels()\n    allLayers = list( set(\[c.split('.')\[0] for c in allChannels]) )\n    allLayers.sort()\n\n    retMatchLayers = \[]\n    retNotMatchLayers = \[]\n    for p in pattern.replace(' ','').split(','):\n        #---- find the layers we want to break out\n        if len(p.split('/')\[0].split('^')) == 1:\n            matchLayers = fnmatch.filter(allLayers, p)\n            if len(matchLayers) : print ('+match \{0\} to \{1\}'.format(p,matchLayers))\n            if p\[0] == '!':\n                notMatchLayers = fnmatch.filter(allLayers, p\[1:])\n                if len(notMatchLayers) : print ('-match \{0\} to \{1\}'.format(p,notMatchLayers))\n                retNotMatchLayers += notMatchLayers\n            matchLayers.sort()               \n            retMatchLayers += matchLayers\n        \n        #---- find the layers we want to divide and mult back together             \n        if len(p.split('/'))>1:\n            pQ = p.split('/')\[0]\n            pD = p.split('/')\[1]\n            if pD in allLayers:\n                matchDivLayers = fnmatch.filter(allLayers, pQ)\n                matchDivLayers = list(map(lambda x: x+'/'+pD, matchDivLayers))\n                if len(matchDivLayers) : print ('+matched \{0\} to \{1\}'.format(p,matchDivLayers))\n                if p\[0] == '!':\n                    notMatchLayers = fnmatch.filter(allLayers, pQ\[1:])\n                    notMatchLayers = list(map(lambda x: x+'/'+pD, notMatchLayers))\n                    if len(notMatchLayers) : print ('-matched \{0\} to \{1\}'.format(p,notMatchLayers))\n                    retNotMatchLayers += notMatchLayers\n                matchLayers.sort()\n                retMatchLayers += matchDivLayers\n        \n        #---- find the layers we want to mult back together    \n        if len(p.split('^'))>1:\n            pQ = p.split('^')\[0]\n            pD = p.split('^')\[1]\n            if pD in allLayers:\n                matchDivLayers = fnmatch.filter(allLayers, pQ)\n                matchDivLayers = list(map(lambda x: x+'^'+pD, matchDivLayers))\n                if len(matchDivLayers) : print ('+matched \{0\} to \{1\}'.format(p,matchDivLayers))\n                if p\[0] == '!':\n                    notMatchLayers = fnmatch.filter(allLayers, pQ\[1:])\n                    notMatchLayers = list(map(lambda x: x+'^'+pD, notMatchLayers))\n                    if len(notMatchLayers) : print ('-matched \{0\} to \{1\}'.format(p,notMatchLayers))\n                    retNotMatchLayers += notMatchLayers\n                matchLayers.sort()\n                retMatchLayers += matchDivLayers\n                \n    retMatchLayers = \[x for x in retMatchLayers if x not in retNotMatchLayers]\n    if len(retMatchLayers) : print ('layers to recombine \{0\}'.format(retMatchLayers))\n    if direction == -1:\n        retMatchLayers.reverse()\n    return retMatchLayers\n    \ndef createAovTree (startXY,layer,isLastMerge=False):\n    x = startXY\[0]\n    y = startXY\[1]\n    topDot = nuke.nodes.Dot( xpos = x, ypos = y )\n    topDot.setXpos( int( topDot.xpos() - d*6 + n.screenWidth()/2 ) )\n    topDot.setYpos( int( topDot.ypos() - d*6 + n.screenHeight()/2 ) )\n\n    shuffleOut = nuke.nodes.Shuffle( xpos = x, ypos = topDot.ypos() + gh*yOffset1-th*0.66  )\n    shuffleOut\['label'].setValue('<b>\[value in] -> \[value out]')\n    shuffleOut\['in'].setValue(layer)\n    shuffleOut\['out'].setValue('rgb')\n    shuffleOut.setInput(0,topDot)\n\n    unpremult = nuke.nodes.Unpremult( xpos = x, ypos = shuffleOut.ypos() + gh*yOffset1+th*0.5  )\n    unpremult.setInput(0,shuffleOut)\n\n    unDot = nuke.nodes.Dot( xpos = x, ypos = unpremult.ypos() + gh*yOffset1 )\n    unDot.setXpos( int( unDot.xpos() - d*6 + n.screenWidth()/2 ) )\n    unDot.setYpos( int( unDot.ypos() - d*6 + n.screenHeight()/2 ) )\n    unDot.setInput(0,unpremult)\n        \n    shuffleIn = nuke.nodes.Shuffle( xpos = x, ypos = unDot.ypos() + gh*yOffset2+th*0.66  )\n    shuffleIn\['label'].setValue('<b>\[value in] -> \[value out]')\n    shuffleIn\['out'].setValue(layer)\n    shuffleIn\['in'].setValue('rgb')\n    shuffleIn.setInput(0,unDot)\n\n    premult = nuke.nodes.Premult( xpos = x, ypos = shuffleIn.ypos() + gh*yOffset1+th*0.34  )\n    premult\['channels'].setValue(layer)\n    premult.setInput(0,shuffleIn)\n\n    if isLastMerge:\n        bottomMerge = nuke.nodes.Remove( xpos = x, ypos = premult.ypos()+yOffset1*gh )\n        bottomMerge\['operation'].setValue('keep')\n        bottomMerge\['channels'].setValue('rgba')\n        bottomMerge\['label'].setValue('keep \[value channels]')            \n        bottomMerge.setInput(0,premult)\n    else:\n        bottomMerge = nuke.nodes.Merge2( xpos = x, ypos = premult.ypos()+yOffset1*gh )\n        bottomMerge\['operation'].setValue('plus')\n        bottomMerge\['Achannels'].setValue('rgb')\n        bottomMerge\['Bchannels'].setValue('rgb')\n        bottomMerge\['output'].setValue('rgb')\n        bottomMerge\['also_merge'].setValue(layer)\n        bottomMerge\['label'].setValue('also \[value also_merge]')            \n        bottomMerge.setInput(1,premult)\n    return \[topDot,unDot,bottomMerge]    \n    \ndef createDivMultTree():\n    #TBC   \n    pass\ndef createMultTree(): \n    #TBC\n    pass\ndef createOrphanTree (startXY):\n    x = startXY\[0]\n    y = startXY\[1]\n    topDot = nuke.nodes.Dot( xpos = x, ypos = y )\n    topDot.setXpos( int( topDot.xpos() - d*6 + n.screenWidth()/2 ) )\n    topDot.setYpos( int( topDot.ypos() - d*6 + n.screenHeight()/2 ) )\n\n    unpremult = nuke.nodes.Unpremult( xpos = x, ypos = topDot.ypos() + gh*yOffset1  )\n    unpremult.setInput(0,topDot)\n\n    topMerge = nuke.nodes.Merge2( xpos = x, ypos = unpremult.ypos()+yOffset1*gh*2 )\n    topMerge\['operation'].setValue('from')\n    topMerge\['Achannels'].setValue('rgb')\n    topMerge\['Bchannels'].setValue('rgb')\n    topMerge\['output'].setValue('rgb')\n    topMerge.setInput(0,unpremult)\n\n    premult = nuke.nodes.Premult( xpos = x, ypos = topMerge.ypos() + gh*(yOffset1+yOffset2) +th*1.25 )\n    premult\['channels'].setValue('rgb')\n    premult.setInput(0,topMerge)\n\n    bottomMerge = nuke.nodes.Merge2( xpos = x, ypos = premult.ypos()+yOffset1*gh )\n    bottomMerge\['operation'].setValue('plus')\n    bottomMerge\['Achannels'].setValue('rgb')\n    bottomMerge\['Bchannels'].setValue('rgb')\n    bottomMerge\['output'].setValue('rgb')\n    bottomMerge.setInput(1,premult)\n    return \[topDot,topMerge,bottomMerge]\n            \ndef breakout(n):\n    #---- find the layers we want to break out\n    pattern = n\['aov_pattern'].value()\n    pattern = resolveEnvVars(pattern)        \n    \n    #exit early if there is no string\n    if len(pattern) == 0:\n        nuke.message ('Nothing to breakout')\n        return\n\n    matchLayers = retrieveLayers(n,pattern)\n    \n    #exit early if there is no layer match\n    if len(matchLayers) == 0:\n        nuke.message ('Nothing to breakout')\n        return\n   \n    #build a tree\n    i=1\n    nx = n.xpos()\n    ny = n.ypos()\n    previousMerge=None\n    firstMerge=None\n    firstDot = nuke.nodes.Dot( xpos = nx, ypos = ny+gh*yOffset1*2 )\n    firstDot.setXpos( int( firstDot.xpos() - d*6 + n.screenWidth()/2 ) )\n    firstDot.setYpos( int( firstDot.ypos() - d*6 + n.screenHeight()/2 ) )\n    firstDot.setInput(0,n)\n    previousDot=firstDot\n    \n    nodeTrees = \[]\n    \n    #build a tree that we can subtract the AOVs from\n    #to gather up any left over data that wasn't captured by the renderer\n    #or if lighting broke the lightgroups\n    x = nx+gw*xOffset\n    if n\['merge_orphan_aovs'].value():      \n        y = ny+gh*yOffset1*2\n        nodes = createOrphanTree(\[x,y])\n        thisDot = nodes\[0]\n        thisDot.setInput(0,previousDot)\n        previousDot = thisDot\n        firstMerge= nodes\[2]\n        previousMerge=firstMerge\n        x = previousMerge.xpos()+gw*xOffset\n        nodeTrees.append(nodes)      \n    \n    for m in matchLayers:\n        y = ny+gh*yOffset1*2\n        isLastTree = False\n        if i == len(m) : isLastTree = True\n        nodes = createAovTree(\[x,y],m,isLastTree)\n        nodeTrees.append(nodes)\n        thisDot = nodes\[0]\n        thisDot.setInput(0,previousDot)\n        previousDot = thisDot\n\n        if not n\['merge_orphan_aovs'].value() and i==1:\n            firstMerge= nodes\[2]\n            previousMerge=firstMerge\n            \n        thisMerge = nodes\[2]\n        previousMerge.setInput(0,thisMerge)\n        previousMerge = thisMerge\n        x = previousMerge.xpos()+gw*xOffset\n        i+=1\n                \n\n\n    #subtract the AOVs from the rgb\n    if n\['merge_orphan_aovs'].value():\n        m = nodeTrees\[0]\[1]\n        j = 1\n        for t in nodeTrees:\n            print(j)\n            if m!=t\[1]:\n                m.setInput(j,t\[1])\n                j+=1\n                if j==2:j=3\n                \n            \n    copy = nuke.nodes.Merge2( xpos = nx, ypos = previousMerge.ypos()+th/4 )\n    copy.setInput(1,firstMerge)\n    copy\['operation'].setValue('copy')\n    copy\['Achannels'].setValue('rgb')\n    copy\['Bchannels'].setValue('rgb')\n    copy\['output'].setValue('rgb')\n    copy\['also_merge'].setValue('all')\n    copy\['bbox'].setValue('B')\n\n    preCopyDot1 = nuke.nodes.Dot( xpos = nx, ypos = copy.ypos()-yOffset1*gh)\n    preCopyDot1.setXpos( int( preCopyDot1.xpos() - d*6 + n.screenWidth()/2 ) )\n    preCopyDot1.setYpos( int( preCopyDot1.ypos() - d*6 + n.screenHeight()/2 ) )\n    preCopyDot1.setInput(0,firstDot)\n    copy.setInput(0,preCopyDot1)\n\n    preCopyDot2 = nuke.nodes.Dot( xpos = nx+gw*(-1)*xOffset, ypos = copy.ypos()-yOffset1*gh)\n    preCopyDot2.setXpos( int( preCopyDot2.xpos() - d*6 + n.screenWidth()/2 ) )\n    preCopyDot2.setYpos( int( preCopyDot2.ypos() - d*6 + n.screenHeight()/2 ) )\n    preCopyDot2.setInput(0,preCopyDot1)\n\n    preCopyDot3 = nuke.nodes.Dot( xpos = nx+gw*(-1)*xOffset, ypos = copy.ypos()+yOffset1*gh+th/2)\n    preCopyDot3.setXpos( int( preCopyDot3.xpos() - d*6 + n.screenWidth()/2 ) )\n    preCopyDot3.setYpos( int( preCopyDot3.ypos() - d*6 + n.screenHeight()/2 ) )\n    preCopyDot3.setInput(0,preCopyDot2)\n\n    copyAlpha = nuke.nodes.Copy( xpos = nx, ypos = copy.ypos()+yOffset1*gh+th/4 )\n    copyAlpha.setInput(0,copy)\n    copyAlpha.setInput(1,preCopyDot3)\n    copyAlpha\['bbox'].setValue('B')\n\n    premultEnd = nuke.nodes.Premult( xpos = nx, ypos = copyAlpha.ypos() + gh*yOffset1  )\n    premultEnd.setInput(0,copyAlpha)\n    \n    for e in n.dependent():\n        for i in range (e.inputs()):\n            if e.input(i)==n:\n                e.setInput(i,premultEnd)\n        \n    \nbreakout(n)" +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 version l "" +STARTLINE T "Creates a tree of lightgroups or illumination passes and recombines them.\n\nv005 @darkness 2022-05-22\nhttps://github.com/artandmath/aov_krakout"}
}
